---
title: hooks分类
---

# hooks 分类

## useState

组件状态呢，主要用`useState`，这个不多说了，不过有几个注意点如下：

- 1、尽量不要保存可以通过计算得到的值，比如说：
  - （1）从 `props` 传递过来的值。有时候 `props` 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 `state` 里。
  - （2）从 URL 中读到的值。比如有时需要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候从 URL 中读取，而不是读出来直接放到 `state` 里。
  - （3）从 `cookie、localStorage` 中读取的值。通常来说，也是每次要用的时候直接去读取，而不是读出来后放到 `state` 里。

## useEffect

函数式组件使用生命周期主要就在这个`hooks`

```js
useEffect(callback, deps);
```

`deps`参数分几种情况：

- 1、没有依赖项，这样的话，每次组件 render 就会执行，换句话说，每次组件跟新就会只想这个 hooks。
- 2、依赖项为空数组，组件首次加载时执行，类似于`class`组件的`componentDidMount`，vue 的`mounted`。
- 3、依赖项数组有值，则会在依赖项里的值改变时，触发。

`useEffect`还可以返回一个函数，用于组件销毁时做一些清理工作，就直接类比 vue 的`destroyed`函数

```js
useEffect(() => {
  const handler = () => {
    // todu
  };
  window.addEventListener("resize", handler);
  return () => {
    window.removeEventListener("resize", handler);
  };
}, []);
```

另外在定义`useEffect`依赖项的话，要注意以下几点：

- 1、定义的依赖项一定要在回调函数中用到，不然你定义的这个没意思。
- 2、`react`会在两次的跟新中，对依赖项进行浅比较，如果你依赖项传的是一个数组或者对象，即使值相等，`react`也会认为发生了改变，从而执行`useEffect`的回调。发生的原因是，函数组件每次调用时，里面的变量都会重新创建一遍。

### hooks 使用注意事项

- 1、hooks 只能在函数组件的顶级作用域中使用，说白了不能把 hooks 定义在一些判断条件里，而且 hooks 内部是按照顺序执行的。
- 2、hooks 只能在函数组件或者其它 hooks 中使用，就是只能用在函数组件或者自定义的 hooks 中。

## useCallback（缓存函数）

主要用于给函数加缓存（缓存引用）。

```js
const fun = useCallback(callback, deps);
```

只有当`dep`改变时，函数才会被重新定义。

## useMemo（缓存计算结果）

类比 vue 的`computed`，缓存的是计算过后的值。

```js
useMemo(callback, deps);
```

举例如下：

```js
function Users() {
  const [list, setList] = useState(["张三", "李四", "赵四"]);
  const [searchKey, setSearchKey] = useState("");

  const getUserList = useMemo(() => {
    console.log("执行了");
    if (searchKey) {
      return list.filter((item) => item.indexOf(searchKey) !== -1);
    } else {
      return list;
    }
  }, [searchKey, list]);
  return (
    <div>
      <input
        value={searchKey}
        type="text"
        onChange={(e) => setSearchKey(e.target.value)}
      />
      <ul>
        {getUserList.length && getUserList.map((item) => <li>{item}</li>)}
      </ul>

      <button onClick={() => setCount(count + 1)}>{count}</button>
    </div>
  );
}
```

另外 useMemo 还可以避免子组件`重复渲染`
例子后面补充

## useRef

在多次渲染之间共享数据，可以保存`DOM`节点的引用，并且改变不会触发组件的重新渲染。

## useContext

从上往下的一个全局状态管理，类似主题颜色这种。

```js
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee",
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222",
  },
};
// 创建一个 Theme 的 Context
const ThemeContext = React.createContext(themes.light);
function App() {
  // 整个应用使用 ThemeContext.Provider 作为根组件
  return (
    // 使用 themes.dark 作为当前 Context
    <ThemeContext.Provider value={themes.dark}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}
// 在 Toolbar 组件中使用一个会使用 Theme 的 Button
function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}
// 在 Theme Button 中使用 useContext 来获取当前的主题
function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button
      style={{
        background: theme.background,
        color: theme.foreground,
      }}
    >
      I am styled by theme context!
    </button>
  );
}
```
