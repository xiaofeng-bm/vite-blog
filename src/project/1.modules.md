# 模块化规范
模块化的核心包括以下特性，基本都是围绕如何处理文件(模块)。
- 拆分：将代码根据功能拆分为多个可复用模块
- 加载：通过指定方式加载模块并执行与输出模块
- 注入：将一个模块的输出注入到另一个模块
- 管理：因为工程模块数量众多需管理模块间的依赖关系

模块化的好处有以下几点：
- 隔离作用域
- 提供复用性
- 提高可维护性
- 解决命名冲突
- 抽离公共代码

模块化发展经历了好些个版本，从最初的立即执行函数（IIFE）到后来的`AMD`、`CMD`、`CJS`到现在前端用的最多的`ESM`。发展到目前，只需要关注`ESM`、和`CJS`这两种了，其它的基本上没见有用的了

`CJS`和`ESM`有一些不一样的地方，具体如下：

| -                             | CJS                           | ESM                          |
| ----------------------------- | ----------------------------- | ---------------------------- |
| 语法类型 | 动态 | 静态 |
| 关键声明 | `require` | `import` `export` | 
| 加载方式 | 运行时加载 | 编译时加载 |
| 加载行为 | 同步加载 | 异步加载 |
| 书写位置 | 任何位置 | 顶层位置 |
| 指针指向 | this指向当前模块 | this指向undefined | 
| 执行顺序 | 首次引用时加载模块 <br> 再次引用时读取缓存 | 引用时生成只读引用 <br> 执行时才是正式取值 | 
| 属性引用 | 基本类型属于复制不共享 <br> 引用类型属于浅拷贝且共享 | 所有类型属于动态只读引用 |  

两者最大的区别就是，`CJS`是运行时加载，`ESM`是编译时加载
- **运行时加载**指整体加载模块生成一个对象，再从对象中获取所需的属性方法去加载。最大特性是`全部加载`，只有运行时才能得到该对象，无法在编译时做静态优化。
- **编译时加载**指直接从模块中获取所需的属性方法去加载。最大特性是`按需加载`，在编译时就完成模块加载，效率比其他方案高，无法引用模块本身(本身不是对象)，但可拓展JS高级语法(宏与类型校验)。

